var searchIndex = JSON.parse('{\
"story_gen":{"doc":"This module contains most of the business logic required …","t":[3,3,3,11,11,11,11,11,11,11,11,5,11,12,11,11,11,11,11,11,0,11,11,11,12,11,11,11,12,12,5,5,5,12,0,12,5,12,11,11,11,11,11,11,11,11,11,11,11,11,3,18,3,18,18,18,3,11,11,11,11,11,11,11,11,5,11,11,11,11,11,11,11,11,11,11,11,11,11,11,5,11,11,11,12,12,11,11,11,11,11,11,11,11,11,11,11,12,12,12,11,11,11,5],"n":["Combinations","Config","Rule","add_optional","add_required","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","convert_sentences_to_paragraphs","default","filename","fmt","fmt","fmt","from","from","from","grammar","into","into","into","left_hand","new","new","new","options","paragraph_length","parse_file","parse_right_hand_side","process_rhs_optional_combinations","quantity","random","right_hand","run","start_nonterminal","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","vzip","vzip","vzip","Grammar","SAFE","Status","UNSAFE","UNVISITED","VISITING","Validator","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","build_random","change_start_nonterminal","dfs","fmt","fmt","from","from","from","generate_sentence","generate_sentences","get_unreachable_nonterminals","get_unreachable_nonterminals","into","into","into","new","new","parse_subunits","rule_add","rule_add_from_file","rule_delete","rules","start_nonterminal","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","validate","validate","validation","validation","validator","vzip","vzip","vzip","get_random_from_vector"],"q":["story_gen","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","story_gen::grammar","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","story_gen::random"],"d":["Used to encapsulate combinatorics logic for optional …","Validates the command line arguments, and stores their …","Represents a grammar rule formed from a single line in …","Add an optional token to the existing options. Each call …","Add a required token to all existing options. Every …","","","","","","","Converts generated sentences into paragraphs of given …","","","","","","","","","This module contains all the grammar rule storage and …","","","","","Given CLI arguments, parse and validate the arguments. …","Takes a line of the file following a specific notation, …","","","","Convert lines from a file into grammar rules Program …","Parses the string that that is to the rigth of the equal …","Converts the RHS vector into representing all possible …","","Module that provides random helper functions that are …","","Main function which runs and controls the life time of …","","","","","","","","","","","","","","This struct is used to manage and store the grammar rules.…","","Used for graph coloring during traversal required for …","","","","Executes all grammar validation logic and stores results …","","","","","","","recursive call, if key doesn’t exist, it must be a …","","Recursive depth first search which marks nodes …","","","","","","Generate a single random sentence from provided …","Generate random sentences starting from LHS non-termianal …","Interface function to get LHS tokens which are not …","Traverses the grammar rules from the starting non-terminal…","","","","","","Used to find all components of an option. When a …","Add the rule with LHS non-terminal ‘key’ and the RHS …","Add a rule struct into the existing grammar rules. If no …","Delete the rule with LHS non-terminal ‘key’. Prints a …","","","","","","","","","","","","Validates the grammer rules have at least 1 valid path. …","Validates the grammar rules to ensure there are no cycles …","","","","","","","Uses uniform distribution to select a random element from …"],"i":[0,0,0,1,1,2,3,1,2,3,1,0,3,2,2,3,1,2,3,1,0,2,3,1,3,2,3,1,1,2,0,0,0,2,0,3,0,2,2,3,1,2,3,1,2,3,1,2,3,1,0,4,0,4,4,4,0,4,5,6,4,5,6,5,5,0,5,6,4,5,6,5,5,5,6,4,5,6,5,6,0,5,5,5,5,5,4,5,6,4,5,6,4,5,6,5,6,5,6,5,4,5,6,0],"f":[null,null,null,[[["str",15]]],[[["str",15]]],[[]],[[]],[[]],[[]],[[]],[[]],[[["usize",15]],[["vec",3,["string"]],["string",3]]],[[],["rule",3]],null,[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],null,[[]],[[]],[[]],null,[[["args",3]],[["result",4,["config","str"]],["config",3],["str",15]]],[[["str",15]],[["result",4,["rule","str"]],["rule",3],["str",15]]],[[],["combinations",3]],null,null,[[["str",15]],[["vec",3,["rule"]],["rule",3]]],[[["str",15]],[["vec",3,["string"]],["string",3]]],[[],[["vec",3,["string"]],["string",3]]],null,null,null,[[["config",3]],[["box",3,["error"]],["result",4,["box"]]]],null,[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[]],[[]],[[]],null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[["str",15]],["string",3]],[[["str",15]]],[[["hashmap",3],["str",15],["hashmap",3]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[["str",15]],["string",3]],[[["str",15],["i32",15]],[["vec",3,["string"]],["string",3]]],[[],[["vec",3,["string"]],["string",3]]],[[["str",15],["hashmap",3]],[["vec",3,["string"]],["string",3]]],[[]],[[]],[[]],[[],["grammar",3]],[[],["validator",3]],[[["str",15]],[["vec",3,["string"]],["string",3]]],[[["str",15]]],[[["rule",3]]],[[["str",15]]],null,null,[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],[["string",3],["result",4,["string"]]]],[[["hashmap",3]],[["string",3],["result",4,["string"]]]],null,null,null,[[]],[[]],[[]],[[],["string",3]]],"p":[[3,"Combinations"],[3,"Config"],[3,"Rule"],[3,"Status"],[3,"Grammar"],[3,"Validator"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};